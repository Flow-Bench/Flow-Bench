# FlowBench文档

## 什么是FlowBench？

FlowBench是用来生成流表和流量的工具套件。它基于不同规则之间的依赖关系工作。我们希望它能够补充经典的类ClassBench工具，并支持对现有和未来算法进行更好控制和更全面的评估。

FlowBench基于有向无环图（DAG）的抽象工作。流表中的每个规则对应 DAG 中的一个节点，两个节点之间的边表示对应规则的重叠关系。FlowBench旨在生成一个流量表，其对应的DAG满足用户给出的一些条件，并允许用户自定义匹配字段。

FlowBench将在INFOCOM'23上发布。如果您对我们的详细信息有任何疑问或感兴趣，请联系通讯作者刘斌（lmyujie@gmail.com）或第一作者陈智康（clazychen@gmail.com）。

## 为什么使用FlowBench？

ClassBench及其改进版本，例如ClassBench-ng，是用于生成流表的常用工具。它们遵循相同的设计原则，基于真实流量表的样本和从频率统计得出的一组条件概率。与这些工具相比，FlowBench具有以下功能：

1. **字段自定义**。FlowBench允许用户指定具有**任意**位宽和**任意**匹配类型（最长前缀匹配、范围匹配或精确匹配）的匹配字段数。支持IPv4、IPv6、OpenFlow和**任意**自定义协议。
2. **表规模自定义**。FlowBench允许用户指定**精确**和**巨大**的流表规模，并**快速**生成表。秒级生成数百万条规则的大规模流表。
3. **DAG定制**。FlowBench允许用户指定节点**深度**之和`D`或总**边数**`E`的精确或相对值，从而实现对DAG的强大控制。FlowBench为用户提供了极大的灵活性。它可以生成一个完全没有依赖或非常密集依赖的表。
4. **可重复性**。FlowBench允许用户指定随机种子。共享**相同**参数集的不同用户可以获得**相同**结果，从而消除了相互联系的工作量。

## 如何安装FlowBench？

FlowBench是一个跨平台的C++程序，仅依赖于C++标准库。

如果您的C++编译器支持**C++17**标准（我们建议使用`g++ >= 7.3.0`），则`make`编译应该简单快捷。我们已经验证了Windows和Ubuntu上的编译。如果编译有任何问题，请与我们联系。

## 如何使用FlowBench？

在本节中，我们将向您展示如何使用FlowBench生成您自己的流表和流量。

我们将使用默认名称`flowbench`和`flowbench-trace`来引用编译后的流表生成器和跟踪生成器。它们都使用命令行选项。您也可以使用`--help`选项来获取简单的指南。

### 流表生成器的指南

#### 概述

下表总结了 FlowBench 的流程表生成器提供的选项。

```
===================================================================================
| 选项                       | 说明                                                |
|---------------------------------------------------------------------------------|
| -n                         | 流表的大小                                           |
| -o                         | 输出文件的路径                                        |
| -f                         | 字段的数量                                           |
| -fw / --field-width        | 字段的位宽                                           |
| -ft / --field-type         | 字段的匹配类型                                        |
| -fwt / --field-weight      | 字段的权重                                           |
| -D / -d                    | DAG中节点深度和的精确/相对值                           |
| -E / -e                    | DAG中总边数的精确/相对值                              |
| -s / --random-seed         | 随机种子                                            |
| --flowbench                | 以FlowBench的样式输出结果（默认）                      |
| --classbench               | 以ClassBench的样式输出结果                            |
| -ar / --arbitrary-range    | 打开“任意范围”特性                                    |
| --dense                    | 打开“密集模式”特性                                    |
| -p / --protocol            | 使用预定义协议                                        |
===================================================================================
```

您可以简单地使用默认选项运行`flowbench`，以获取包含4096条规则的IPv4五元组流表。

我们将在以下几个小节中介绍如何使用这些选项。

#### 表规模自定义

##### 例子

`flowbench -n 4096` （生成包含4096条规则的流表）

##### 说明

我们的实验表明，FlowBench的时间消耗与`-n`给出的参数具有近似线性关系。在我们的机器上，2秒内可以生成1048576个IPv4五元组规则（输出时间不计算）。您可以放心地生成相对较大的流表。

请注意，由于字段的位宽和匹配类型，表大小存在限制。例如，当只有一个3位EM字段时，您永远无法生成10条规则，因为只有9个不同的候选项（8个精确值和通配符）。此外，FlowBench可能无法达到表大小的理论上限。如果指定的大小太大，FlowBench将引发错误。您可以尝试`--dense`来启用“密集模式”（将在下面的小节中说明），或将大小替换为较小的大小。

#### 字段自定义

##### 例子

`flowbench -f 5 -fw 32 32 16 16 8 -ft LPM LPM RM RM EM` （IPv4五元组）

`flowbench -f 5 -fw 128 128 16 16 8 -ft LPM LPM RM RM EM` （IPv6五元组）

`flowbench -f 12 -fw 16 48 48 16 8 16 8 8 32 32 16 16 -ft EM EM EM EM EM EM EM EM LPM LPM RM RM ` （OpenFlow 1.0十二元组）

##### 说明

字段自定义包括3个选项：`-f`、`-fw`和`-ft`。默认值为IPv4五元组。

`-f`用于指定匹配字段的数量。您应该先指定`-f`，然后使用相同数量的参数指定`-fw`和`-ft`。FlowBench支持3种匹配类型：最长前缀匹配（LPM）、范围匹配（RM） 和精确匹配（EM）。

我们的实验表明，FlowBench的时间消耗与`-f`给出的参数具有近似线性关系。由于FlowBench使用32位数据参与操作，因此当您指定大于32的位宽（例如MAC地址和IPv6地址）时，它可能会慢一些。另一方面，匹配类型对时间没有显著影响。

为了简化常用协议，FlowBench提供了另一个选项`-p`或`--protocol`。您可以使用`-p ipv4`、`-p ipv6`和`-p openflow1.0`来使用预定义的协议。

#### 字段权重指定

##### 例子

`flowbench -p ipv4 -fwt 1.0 1.0 1.0 1.0 1.0` （给IPv4的5个字段相同的权重）

##### 说明

`-fwt`用于控制每个字段的依赖概率。如果为字段指定更大的权重，则LPM会有更多的前缀长度，RM有更多的不同区间，EM有更多的精确值。相反，如果将字段的权重设置为`0.0`，则表中每个规则的此字段都将是通配符。

请注意，重要的是相对值而不是绝对值。例如，`-fwt 1.0 2.0`等效于`-fwt 0.5 1.0`，因为它们的权重比相同。

如果未指定`-fwt`，FlowBench将使用默认权重：LPM和RM字段的权重等于其位宽，EM字段的权重等于`1.0`。例如，`flowbench -p ipv4`等效于`flowbench -p ipv4 -fwt 32 32 16 16 1`。

#### DAG自定义

##### 例子

`flowbench -D 120`（节点深度和为120）

`flowbench -E 120`（总边数为120）

`flowbench -d 0.7`（节点深度和的“相对”值为0.7）

##### 说明

FlowBench提供`-D`和`-E`来指定相应DAG的参数`D`和`E`的精确值，其中`D`表示节点深度的总和，`E`表示边的总数。例如，下面的DAG具有`D=4`和`E=3`。

```
A ----------> B       depth(A) = 0
|                     depth(B) = depth(C) = 1
|                     depth(D) = 2       
|                     D = 0 + 1 + 1 + 2 = 4
|                     E                 = 3
V              
C ----------> D
```

精确的值有一些缺点。在密度方面，具有不同大小的DAG可能会有显著差异，即使它们具有相同的`D`或`E`。为了允许用户在不同尺寸的流量表上进行实验时使用相同的指标，FlowBench提供了`-d`和`-e`来指定参数`D`和`E`的“相对”值。例如，`flowbench -d 0.7`表示`D`的相对值为`0.7`。

FlowBench设置一个与流表的大小`n`相关的基线值`P1`，其中`P1 = O(nlogn)`。如果指定的相对值为`r`，FlowBench将使用`r * P1`计算相应的精确值。除非受到字段位宽的限制，否则FlowBench保证在`r <= 1.0`时可以成功生成流表。当您想要更密集的DAG时，您可以尝试`--dense`以启用“密集模式”，或者在FlowBench引发错误时尝试不同的随机种子。根据我们的经验，当`r > 2.0`时，有很大的风险FlowBench找不到满足您要求的表。

> 如果不受位宽的限制，参数的理论上限为`O(n^2)`，对应于“完全的”DAG。但是，在大多数情况下，无法达到此界限，因为它需要太多的比特。
>
> 当考虑到位宽时，上限仍然是一个未解决的问题。我们已经注意到，FlowBench和边界之间仍然存在巨大的差距，因为我们的算法是基于树的，受到`O(nlogn)`的限制。

不能同时指定`-D`和`-E`，否则只有其中一个指定生效。同样，不能同时指定任一参数的精确值和相对值。如果未指定参数，FlowBench将随机生成一个DAG。

