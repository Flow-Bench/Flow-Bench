#pragma once

// solving a subproblem on the tree
// 1. select a QuadDag
// 2. select some virtual rules
// 3. split the virtual rules
// 4. apply xor operation to the rule set
// 5. convert the candidate rule set to a user-defined rule set
// 6. concatenate the parent virtual rule and the rules we have generated
// 7. random perturb the RM fields (if enabled Arbitrary Range)
// 8. generate new subproblems on the next layer (if required)

#include <queue>

#include "problem_state.hpp"
#include "divider_manager.hpp"
#include "quad_dag_selector.hpp"
#include "rule_virtual_selector.hpp"
#include "rule_virtual_splitter.hpp"
#include "instantiater_bit.hpp"
#include "instantiater_field.hpp"
#include "instantiater_rule.hpp"
#include "random_perturbator.hpp"

namespace flowbench {

class LocalProblem : public Singleton<LocalProblem> {
private:
    // the state of the local subproblem
    std::unique_ptr<ProblemState> state;

    // the user-defined rule set generated by the local subproblem
    std::unique_ptr<UDRuleSet> ruleSet;

    // for debug
    friend std::ostream& operator<<(std::ostream& os, const LocalProblem& problem);

public:
    bool solve(std::unique_ptr<ProblemState> givenState);
    void exportRules(UDRuleSet& finalSet, std::queue<std::unique_ptr<ProblemState>>& stateQueue);

};

bool LocalProblem::solve(std::unique_ptr<ProblemState> givenState) {
    state = std::move(givenState);
    try {
        uint32_t quadDagIndex = QuadDagSelector::getInstance().select(*state);
        const auto& profile = QuadDagPool::getInstance().getProfile(quadDagIndex);
        if (state->n > QD_VERTEX_CNT) {
            VirtualRuleSelector::getInstance().select(*state, profile);
        }
        auto candidateRuleSet = VirtualRuleSplitter::getInstance().split(*state, profile);
        BitInstantiater::getInstance()(*candidateRuleSet);
        ruleSet = FieldInstantiater::getInstance()(*candidateRuleSet, *state, profile);
        RuleInstantiater::getInstance()(*ruleSet, *(state->parent));
        RandomPerturbator::getInstance()(*ruleSet, *(state->parent));
    } catch (const NoCandidateError& e) {
        std::cerr << "    " << e.what() << std::endl;
        return false;
    }
    return true;
}

void LocalProblem::exportRules(UDRuleSet& finalSet, std::queue<std::unique_ptr<ProblemState>>& stateQueue) {
    for (uint8_t i = 0; i < std::min<uint32_t>(QD_VERTEX_CNT, state->n); i++) {
        finalSet.push_back(std::move(ruleSet->at(i)));
    }
    if (state->n > QD_VERTEX_CNT) {
        // Divider divider(state->n - QD_VERTEX_CNT);
        const auto& divider = DividerManager::getInstance().getDivider(state->n - QD_VERTEX_CNT);
        for (uint8_t i = QD_VERTEX_CNT; i < ruleSet->size(); i++) {
            uint32_t childN = divider.result[i - QD_VERTEX_CNT];
            if (childN > 0) {
                stateQueue.push(std::make_unique<ProblemState>(
                    childN,
                    VirtualRuleSelector::getInstance().parameters[i - QD_VERTEX_CNT],
                    VirtualRuleSplitter::getInstance().allowWildcard[i - QD_VERTEX_CNT],
                    std::move(ruleSet->at(i))
                ));
            }
        }
    }
}

std::ostream& operator<<(std::ostream& os, const LocalProblem& problem) {
    os << *(problem.state) << std::endl;
    return os;
}


}