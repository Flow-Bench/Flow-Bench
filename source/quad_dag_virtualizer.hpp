#pragma once

// virtualize the QuadDag
// after instantiation, we have found the solid rules in the candidate rule set
// in this step, we will virtualize the QuadDag, i.e. add virtual rules to the set

#include "singleton.hpp"
#include "rule_set_candidate.hpp"
#include "trie.hpp"

namespace flowbench {

class QuadDagVirtualizer : public Singleton<QuadDagVirtualizer> {
private:
    // we use Tries to generate virtual rule candidates first
    std::array<Trie, QD_FIELD_CNT> tries;

    // initialize the Tries
    void initializeTries(const CandidateRuleSet& solidRules);

    // every leaf on the Trie represents a possible field value in a virtual rule
    // we traverse the Tries and generate all the possible virtual rules recursively
    void traverseTries(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules) const;
    void traverseTries(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules, CandidateRule& currentRule, uint8_t index) const;
    
private:
    // the virtual rules directly generated by the Tries can be classified into different buckets
    // if 2 virtual rules share the same position in the QuadDag, they will be in the same bucket
    // that is, there are the same edges between them and the same solid rules
    constexpr static uint8_t BUCKET_CNT = 1 << QD_VERTEX_CNT;
    std::array<CandidateRuleSet, BUCKET_CNT> buckets;
    
    // initialize the buckets
    void initializeBuckets(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules);

    // we need to merge the rules in the same bucket, to reduce the number of virtual rules
    // merge conditions:
    // 1. in the same bucket
    // 2. there is exactly one different field value
    // 3. the different field can be merged
    //    e.g. 01 and 00 can be merge into 0
    // if the 2 rules can be merged, we will merge them and put the result into the bucket
    // if the 2 rules cannot be merged, we will put them into the bucket directly
    // we will repeat the process until no more rules can be merged
    std::unique_ptr<CandidateRule> mergeRule(const CandidateRule& rule1, const CandidateRule& rule2) const;
    void mergeRules(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules);

public:
    std::unique_ptr<CandidateRuleSet> operator()(const CandidateRuleSet& solidRules) {
        auto result = std::make_unique<CandidateRuleSet>();
        initializeTries(solidRules);
        traverseTries(solidRules, *result);
        initializeBuckets(solidRules, *result);
        mergeRules(solidRules, *result);
        return result;
    }
};

void QuadDagVirtualizer::initializeTries(const CandidateRuleSet& solidRules) {
    for (uint8_t i = 0; i < QD_FIELD_CNT; i++) {
        tries[i].clear();
    }
    for (uint8_t i = 0; i < solidRules.size(); i++) {
        for (uint8_t j = 0; j < QD_FIELD_CNT; j++) {
            tries[j].insert(solidRules.getRule(i).getFieldAs<LpmField<Int32>>(j));
        }
    }
}

void QuadDagVirtualizer::traverseTries(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules) const {
    CandidateRule currentRule;
    traverseTries(solidRules, virtualRules, currentRule, 0);
}

void QuadDagVirtualizer::traverseTries(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules, CandidateRule& currentRule, uint8_t index) const {
    if (index == QD_FIELD_CNT) {
        virtualRules.push_back(currentRule.clone());
        return;
    }
    tries[index].traverse([&](const LpmField<Int32>& field) {
        currentRule.setField(index, field.clone());
        traverseTries(solidRules, virtualRules, currentRule, index + 1);
    });
}

void QuadDagVirtualizer::initializeBuckets(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules) {
    for (auto& bucket : buckets) {
        bucket.clear();
    }
    for (auto& rule : virtualRules) {
        uint8_t bucket = 0;
        for (uint8_t i = 0; i < QD_VERTEX_CNT; i++) {
            if (solidRules.getRule(i).cover(*rule)) {
                bucket |= 1 << i;
            }
        }
        buckets[bucket].push_back(std::move(rule));
    }
    virtualRules.clear();
}

std::unique_ptr<CandidateRule> QuadDagVirtualizer::mergeRule(const CandidateRule& rule1, const CandidateRule& rule2) const {
    auto result = rule1.clone();
    bool different = false;
    for (uint8_t i = 0; i < QD_FIELD_CNT; i++) {
        auto& field1 = rule1.getFieldAs<LpmField<Int32>>(i);
        auto& field2 = rule2.getFieldAs<LpmField<Int32>>(i);
        if (field1 != field2) {
            if (different) {
                return nullptr;
            }
            different = true;
            auto fieldMerged = field1.mergeWith(field2);
            if (fieldMerged == nullptr) {
                return nullptr;
            }
            result->setField(i, std::move(fieldMerged));
        }
    }
    return result;

}

void QuadDagVirtualizer::mergeRules(const CandidateRuleSet& solidRules, CandidateRuleSet& virtualRules) {
    for (auto& bucket : buckets) {
        if (bucket.size() == 0) {
            continue;
        }
        while (bucket.size() > 1) {
            CandidateRuleSet mergedRules;
            std::vector<bool> merged(bucket.size(), false);
            bool mergedAny = false;
            for (uint32_t i = 0; i < bucket.size(); i++) {
                if (merged[i]) {
                    continue;
                }
                for (uint32_t j = i + 1; j < bucket.size(); j++) {
                    auto mergedRule = mergeRule(bucket.getRule(i), bucket.getRule(j));
                    if (mergedRule != nullptr) {
                        mergedRules.push_back(std::move(mergedRule));
                        merged[i] = true;
                        merged[j] = true;
                        mergedAny = true;
                        break;
                    }
                }
            }
            if (!mergedAny) {
                break;
            }
            for (uint32_t i = 0; i < bucket.size(); i++) {
                if (!merged[i]) {
                    mergedRules.push_back(std::move(bucket[i]));
                }
            }
            bucket = std::move(mergedRules);
        }
        for (auto& rule : bucket) {
            virtualRules.push_back(std::move(rule));
        }
    }
}

}